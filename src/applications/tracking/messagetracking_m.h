//
// Generated file, do not edit! Created by opp_msgc 4.4 from applications/tracking/messagetracking.msg.
//

#ifndef _MESSAGETRACKING_M_H_
#define _MESSAGETRACKING_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "messagecr_m.h"
    #include "measurement.h"
    #include "targetpos.h"
    typedef std::list<Measurement> MeasurementList;
    typedef std::list<TargetPos*> TargetPosList;
// }}



/**
 * Enum generated from <tt>applications/tracking/messagetracking.msg</tt> by opp_msgc.
 * <pre>
 * enum MessageType {
 *     MSG_SYNC_REQUEST = 0; 
 *     MSG_SENSE_RESULT = 1; 
 *     MSG_TRACK_RESULT = 2; 
 *     MSG_CH_BEACON = 3; 
 * };
 * </pre>
 */
enum MessageType {
    MSG_SYNC_REQUEST = 0,
    MSG_SENSE_RESULT = 1,
    MSG_TRACK_RESULT = 2,
    MSG_CH_BEACON = 3
};

/**
 * Class generated from <tt>applications/tracking/messagetracking.msg</tt> by opp_msgc.
 * <pre>
 * packet MsgTracking extends MessageCR {
 *     int msgType;
 *     int msgSize = 11; 
 * }
 * </pre>
 */
class MsgTracking : public ::MessageCR
{
  protected:
    int msgType_var;
    int msgSize_var;

  private:
    void copy(const MsgTracking& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MsgTracking&);

  public:
    MsgTracking(const char *name=NULL, int kind=0);
    MsgTracking(const MsgTracking& other);
    virtual ~MsgTracking();
    MsgTracking& operator=(const MsgTracking& other);
    virtual MsgTracking *dup() const {return new MsgTracking(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMsgType() const;
    virtual void setMsgType(int msgType);
    virtual int getMsgSize() const;
    virtual void setMsgSize(int msgSize);
};

inline void doPacking(cCommBuffer *b, MsgTracking& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MsgTracking& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/tracking/messagetracking.msg</tt> by opp_msgc.
 * <pre>
 * packet MsgSyncRequest extends MsgTracking {
 *     int routingType = RT_BROADCAST;
 *     int msgType = MSG_SYNC_REQUEST;
 *     
 * }
 * </pre>
 */
class MsgSyncRequest : public ::MsgTracking
{
  protected:
    int routingType_var;
    int msgType_var;

  private:
    void copy(const MsgSyncRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MsgSyncRequest&);

  public:
    MsgSyncRequest(const char *name=NULL, int kind=0);
    MsgSyncRequest(const MsgSyncRequest& other);
    virtual ~MsgSyncRequest();
    MsgSyncRequest& operator=(const MsgSyncRequest& other);
    virtual MsgSyncRequest *dup() const {return new MsgSyncRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
    virtual int getMsgType() const;
    virtual void setMsgType(int msgType);
};

inline void doPacking(cCommBuffer *b, MsgSyncRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MsgSyncRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/tracking/messagetracking.msg</tt> by opp_msgc.
 * <pre>
 * packet MsgSenseResult extends MsgTracking {
 *     int routingType = RT_BROADCAST;
 *     int msgType = MSG_SENSE_RESULT;
 *     
 *     
 *     MeasurementList meaList;
 *     double nodePosX;
 *     double nodePosY;
 *     double nodeEnergy;
 *     
 *     
 * }
 * </pre>
 */
class MsgSenseResult : public ::MsgTracking
{
  protected:
    int routingType_var;
    int msgType_var;
    MeasurementList meaList_var;
    double nodePosX_var;
    double nodePosY_var;
    double nodeEnergy_var;

  private:
    void copy(const MsgSenseResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MsgSenseResult&);

  public:
    MsgSenseResult(const char *name=NULL, int kind=0);
    MsgSenseResult(const MsgSenseResult& other);
    virtual ~MsgSenseResult();
    MsgSenseResult& operator=(const MsgSenseResult& other);
    virtual MsgSenseResult *dup() const {return new MsgSenseResult(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
    virtual int getMsgType() const;
    virtual void setMsgType(int msgType);
    virtual MeasurementList& getMeaList();
    virtual const MeasurementList& getMeaList() const {return const_cast<MsgSenseResult*>(this)->getMeaList();}
    virtual void setMeaList(const MeasurementList& meaList);
    virtual double getNodePosX() const;
    virtual void setNodePosX(double nodePosX);
    virtual double getNodePosY() const;
    virtual void setNodePosY(double nodePosY);
    virtual double getNodeEnergy() const;
    virtual void setNodeEnergy(double nodeEnergy);
};

inline void doPacking(cCommBuffer *b, MsgSenseResult& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MsgSenseResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/tracking/messagetracking.msg</tt> by opp_msgc.
 * <pre>
 * packet MsgTrackResult extends MsgTracking {
 *     int routingType = RT_TO_BS;
 *     int msgType = MSG_TRACK_RESULT;
 *     
 *     
 *     TargetPosList tpList;
 *     
 *     
 *     
 *     
 *     simtime_t tsSense;
 * }
 * </pre>
 */
class MsgTrackResult : public ::MsgTracking
{
  protected:
    int routingType_var;
    int msgType_var;
    TargetPosList tpList_var;
    simtime_t tsSense_var;

  private:
    void copy(const MsgTrackResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MsgTrackResult&);

  public:
    MsgTrackResult(const char *name=NULL, int kind=0);
    MsgTrackResult(const MsgTrackResult& other);
    virtual ~MsgTrackResult();
    MsgTrackResult& operator=(const MsgTrackResult& other);
    virtual MsgTrackResult *dup() const {return new MsgTrackResult(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
    virtual int getMsgType() const;
    virtual void setMsgType(int msgType);
    virtual TargetPosList& getTpList();
    virtual const TargetPosList& getTpList() const {return const_cast<MsgTrackResult*>(this)->getTpList();}
    virtual void setTpList(const TargetPosList& tpList);
    virtual simtime_t getTsSense() const;
    virtual void setTsSense(simtime_t tsSense);
};

inline void doPacking(cCommBuffer *b, MsgTrackResult& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MsgTrackResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/tracking/messagetracking.msg</tt> by opp_msgc.
 * <pre>
 * packet MsgCHBeacon extends MsgTracking {
 *     int routingType = RT_BROADCAST;
 *     int msgType = MSG_CH_BEACON;
 *     
 * }
 * </pre>
 */
class MsgCHBeacon : public ::MsgTracking
{
  protected:
    int routingType_var;
    int msgType_var;

  private:
    void copy(const MsgCHBeacon& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MsgCHBeacon&);

  public:
    MsgCHBeacon(const char *name=NULL, int kind=0);
    MsgCHBeacon(const MsgCHBeacon& other);
    virtual ~MsgCHBeacon();
    MsgCHBeacon& operator=(const MsgCHBeacon& other);
    virtual MsgCHBeacon *dup() const {return new MsgCHBeacon(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRoutingType() const;
    virtual void setRoutingType(int routingType);
    virtual int getMsgType() const;
    virtual void setMsgType(int msgType);
};

inline void doPacking(cCommBuffer *b, MsgCHBeacon& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MsgCHBeacon& obj) {obj.parsimUnpack(b);}


#endif // _MESSAGETRACKING_M_H_
